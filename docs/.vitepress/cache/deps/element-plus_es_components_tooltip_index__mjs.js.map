{
  "version": 3,
  "sources": ["../../../../packages/components/popper/src/constants.ts", "../../../../packages/components/popper/src/popper.ts", "../../../../packages/components/popper/src/popper.vue", "../../../../packages/components/popper/src/arrow.ts", "../../../../packages/components/popper/src/arrow.vue", "../../../../packages/components/slot/src/only-child.tsx", "../../../../packages/components/popper/src/trigger.ts", "../../../../packages/components/popper/src/trigger.vue", "../../../../packages/components/focus-trap/src/tokens.ts", "../../../../packages/components/focus-trap/src/utils.ts", "../../../../packages/components/focus-trap/src/focus-trap.vue", "../../../../packages/components/popper/src/content.ts", "../../../../packages/components/popper/src/utils.ts", "../../../../packages/components/popper/src/composables/use-content.ts", "../../../../packages/components/popper/src/composables/use-content-dom.ts", "../../../../packages/components/popper/src/composables/use-focus-trap.ts", "../../../../packages/components/popper/src/content.vue", "../../../../packages/components/popper/index.ts", "../../../../packages/components/tooltip/src/constants.ts", "../../../../packages/components/tooltip/src/content.ts", "../../../../packages/components/tooltip/src/trigger.ts", "../../../../packages/components/tooltip/src/tooltip.ts", "../../../../packages/components/tooltip/src/utils.ts", "../../../../packages/components/tooltip/src/trigger.vue", "../../../../packages/components/tooltip/src/content.vue", "../../../../packages/components/tooltip/src/tooltip.vue", "../../../../packages/components/tooltip/index.ts"],
  "sourcesContent": ["import type { CSSProperties, ComputedRef, InjectionKey, Ref } from 'vue'\nimport type { Instance } from '@popperjs/core'\n\nexport type Measurable = {\n  getBoundingClientRect: () => DOMRect\n}\n\n/**\n * triggerRef indicates the element that triggers popper\n * contentRef indicates the element of popper content\n * referenceRef indicates the element that popper content relative with\n */\nexport type ElPopperInjectionContext = {\n  triggerRef: Ref<Measurable | undefined>\n  contentRef: Ref<HTMLElement | undefined>\n  popperInstanceRef: Ref<Instance | undefined>\n  referenceRef: Ref<Measurable | undefined>\n  role: ComputedRef<string>\n}\n\nexport type ElPopperContentInjectionContext = {\n  arrowRef: Ref<HTMLElement | undefined>\n  arrowOffset: Ref<number | undefined>\n  arrowStyle: ComputedRef<CSSProperties>\n}\n\nexport const POPPER_INJECTION_KEY: InjectionKey<ElPopperInjectionContext> =\n  Symbol('popper')\n\nexport const POPPER_CONTENT_INJECTION_KEY: InjectionKey<ElPopperContentInjectionContext> =\n  Symbol('popperContent')\n", "import { buildProps } from '@element-plus/utils'\n\nimport type { ExtractPropTypes } from 'vue'\nimport type Popper from './popper.vue'\n\nconst effects = ['light', 'dark'] as const\nconst triggers = ['click', 'contextmenu', 'hover', 'focus'] as const\n\nexport const Effect = {\n  LIGHT: 'light',\n  DARK: 'dark',\n} as const\n\nexport const roleTypes = [\n  'dialog',\n  'grid',\n  'group',\n  'listbox',\n  'menu',\n  'navigation',\n  'tooltip',\n  'tree',\n] as const\n\nexport type PopperEffect = typeof effects[number]\nexport type PopperTrigger = typeof triggers[number]\n\nexport const popperProps = buildProps({\n  role: {\n    type: String,\n    values: roleTypes,\n    default: 'tooltip',\n  },\n} as const)\n\nexport type PopperProps = ExtractPropTypes<typeof popperProps>\n\nexport type PopperInstance = InstanceType<typeof Popper>\n\n/** @deprecated use `popperProps` instead, and it will be deprecated in the next major version */\nexport const usePopperProps = popperProps\n\n/** @deprecated use `PopperProps` instead, and it will be deprecated in the next major version */\nexport type UsePopperProps = PopperProps\n", "<template>\n  <slot />\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed, provide, ref } from 'vue'\nimport { POPPER_INJECTION_KEY } from './constants'\nimport { popperProps } from './popper'\n\nimport type { Instance as PopperInstance } from '@popperjs/core'\nimport type { ElPopperInjectionContext } from './constants'\n\ndefineOptions({\n  name: 'ElPopper',\n  inheritAttrs: false,\n})\nconst props = defineProps(popperProps)\n\nconst triggerRef = ref<HTMLElement>()\nconst popperInstanceRef = ref<PopperInstance>()\nconst contentRef = ref<HTMLElement>()\nconst referenceRef = ref<HTMLElement>()\nconst role = computed(() => props.role)\n\nconst popperProvides = {\n  /**\n   * @description trigger element\n   */\n  triggerRef,\n  /**\n   * @description popperjs instance\n   */\n  popperInstanceRef,\n  /**\n   * @description popper content element\n   */\n  contentRef,\n  /**\n   * @description popper reference element\n   */\n  referenceRef,\n  /**\n   * @description role determines how aria attributes are distributed\n   */\n  role,\n} as ElPopperInjectionContext\n\ndefineExpose(popperProvides)\n\nprovide(POPPER_INJECTION_KEY, popperProvides)\n</script>\n", "import { buildProps } from '@element-plus/utils'\n\nimport type { ExtractPropTypes } from 'vue'\nimport type Arrow from './arrow.vue'\n\nexport const popperArrowProps = buildProps({\n  arrowOffset: {\n    type: Number,\n    default: 5,\n  },\n} as const)\nexport type PopperArrowProps = ExtractPropTypes<typeof popperArrowProps>\n\nexport type PopperArrowInstance = InstanceType<typeof Arrow>\n\n/** @deprecated use `popperArrowProps` instead, and it will be deprecated in the next major version */\nexport const usePopperArrowProps = popperArrowProps\n\n/** @deprecated use `PopperArrowProps` instead, and it will be deprecated in the next major version */\nexport type UsePopperArrowProps = PopperArrowProps\n\n/** @deprecated use `PopperArrowInstance` instead, and it will be deprecated in the next major version */\nexport type ElPopperArrowInstance = PopperArrowInstance\n", "<template>\n  <span\n    ref=\"arrowRef\"\n    :class=\"ns.e('arrow')\"\n    :style=\"arrowStyle\"\n    data-popper-arrow\n  />\n</template>\n\n<script lang=\"ts\" setup>\nimport { inject, onBeforeUnmount, watch } from 'vue'\nimport { useNamespace } from '@element-plus/hooks'\nimport { POPPER_CONTENT_INJECTION_KEY } from './constants'\nimport { popperArrowProps } from './arrow'\n\ndefineOptions({\n  name: 'ElPopperArrow',\n  inheritAttrs: false,\n})\n\nconst props = defineProps(popperArrowProps)\n\nconst ns = useNamespace('popper')\nconst { arrowOffset, arrowRef, arrowStyle } = inject(\n  POPPER_CONTENT_INJECTION_KEY,\n  undefined\n)!\n\nwatch(\n  () => props.arrowOffset,\n  (val) => {\n    arrowOffset.value = val\n  }\n)\nonBeforeUnmount(() => {\n  arrowRef.value = undefined\n})\n\ndefineExpose({\n  /**\n   * @description Arrow element\n   */\n  arrowRef,\n})\n</script>\n", "import {\n  Comment,\n  Fragment,\n  Text,\n  cloneVNode,\n  defineComponent,\n  inject,\n  withDirectives,\n} from 'vue'\nimport { NOOP, isObject } from '@vue/shared'\nimport {\n  FORWARD_REF_INJECTION_KEY,\n  useForwardRefDirective,\n  useNamespace,\n} from '@element-plus/hooks'\nimport { debugWarn } from '@element-plus/utils'\n\nimport type { Ref, VNode } from 'vue'\n\nconst NAME = 'ElOnlyChild'\n\nexport const OnlyChild = defineComponent({\n  name: NAME,\n  setup(_, { slots, attrs }) {\n    const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY)\n    const forwardRefDirective = useForwardRefDirective(\n      forwardRefInjection?.setForwardRef ?? NOOP\n    )\n    return () => {\n      const defaultSlot = slots.default?.(attrs)\n      if (!defaultSlot) return null\n\n      if (defaultSlot.length > 1) {\n        debugWarn(NAME, 'requires exact only one valid child.')\n        return null\n      }\n\n      const firstLegitNode = findFirstLegitChild(defaultSlot)\n      if (!firstLegitNode) {\n        debugWarn(NAME, 'no valid child node found')\n        return null\n      }\n\n      return withDirectives(cloneVNode(firstLegitNode!, attrs), [\n        [forwardRefDirective],\n      ])\n    }\n  },\n})\n\nfunction findFirstLegitChild(node: VNode[] | undefined): VNode | null {\n  if (!node) return null\n  const children = node as VNode[]\n  for (const child of children) {\n    /**\n     * when user uses h(Fragment, [text]) to render plain string,\n     * this switch case just cannot handle, when the value is primitives\n     * we should just return the wrapped string\n     */\n    if (isObject(child)) {\n      switch (child.type) {\n        case Comment:\n          continue\n        case Text:\n        case 'svg':\n          return wrapTextContent(child)\n        case Fragment:\n          return findFirstLegitChild(child.children as VNode[])\n        default:\n          return child\n      }\n    }\n    return wrapTextContent(child)\n  }\n  return null\n}\n\nfunction wrapTextContent(s: string | VNode) {\n  const ns = useNamespace('only-child')\n  return <span class={ns.e('content')}>{s}</span>\n}\n\nexport type OnlyChildExpose = {\n  forwardRef: Ref<HTMLElement>\n}\n", "import { buildProps, definePropType } from '@element-plus/utils'\n\nimport type { Measurable } from './constants'\nimport type Trigger from './trigger.vue'\n\nexport const popperTriggerProps = buildProps({\n  virtualRef: {\n    type: definePropType<Measurable>(Object),\n  },\n  virtualTriggering: Boolean,\n  onMouseenter: {\n    type: definePropType<(e: Event) => void>(Function),\n  },\n  onMouseleave: {\n    type: definePropType<(e: Event) => void>(Function),\n  },\n  onClick: {\n    type: definePropType<(e: Event) => void>(Function),\n  },\n  onKeydown: {\n    type: definePropType<(e: Event) => void>(Function),\n  },\n  onFocus: {\n    type: definePropType<(e: Event) => void>(Function),\n  },\n  onBlur: {\n    type: definePropType<(e: Event) => void>(Function),\n  },\n  onContextmenu: {\n    type: definePropType<(e: Event) => void>(Function),\n  },\n  id: String,\n  open: Boolean,\n} as const)\n\nexport type PopperTriggerProps = typeof popperTriggerProps\n\nexport type PopperTriggerInstance = InstanceType<typeof Trigger>\n\n/** @deprecated use `popperTriggerProps` instead, and it will be deprecated in the next major version */\nexport const usePopperTriggerProps = popperTriggerProps\n\n/** @deprecated use `PopperTriggerInstance` instead, and it will be deprecated in the next major version */\nexport type ElPopperArrowTrigger = PopperTriggerInstance\n", "<template>\n  <el-only-child\n    v-if=\"!virtualTriggering\"\n    v-bind=\"$attrs\"\n    :aria-controls=\"ariaControls\"\n    :aria-describedby=\"ariaDescribedby\"\n    :aria-expanded=\"ariaExpanded\"\n    :aria-haspopup=\"ariaHaspopup\"\n  >\n    <slot />\n  </el-only-child>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed, inject, onBeforeUnmount, onMounted, watch } from 'vue'\nimport { isNil } from 'lodash-unified'\nimport { unrefElement } from '@vueuse/core'\nimport { ElOnlyChild } from '@element-plus/components/slot'\nimport { useForwardRef } from '@element-plus/hooks'\nimport { isElement } from '@element-plus/utils'\nimport { POPPER_INJECTION_KEY } from './constants'\nimport { popperTriggerProps } from './trigger'\n\nimport type { WatchStopHandle } from 'vue'\n\ndefineOptions({\n  name: 'ElPopperTrigger',\n  inheritAttrs: false,\n})\n\nconst props = defineProps(popperTriggerProps)\n\nconst { role, triggerRef } = inject(POPPER_INJECTION_KEY, undefined)!\n\nuseForwardRef(triggerRef)\n\nconst ariaControls = computed<string | undefined>(() => {\n  return ariaHaspopup.value ? props.id : undefined\n})\n\nconst ariaDescribedby = computed<string | undefined>(() => {\n  if (role && role.value === 'tooltip') {\n    return props.open && props.id ? props.id : undefined\n  }\n  return undefined\n})\n\nconst ariaHaspopup = computed<string | undefined>(() => {\n  if (role && role.value !== 'tooltip') {\n    return role.value\n  }\n  return undefined\n})\n\nconst ariaExpanded = computed<string | undefined>(() => {\n  return ariaHaspopup.value ? `${props.open}` : undefined\n})\n\nlet virtualTriggerAriaStopWatch: WatchStopHandle | undefined = undefined\n\nonMounted(() => {\n  watch(\n    () => props.virtualRef,\n    (virtualEl) => {\n      if (virtualEl) {\n        triggerRef.value = unrefElement(virtualEl as HTMLElement)\n      }\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  watch(\n    triggerRef,\n    (el, prevEl) => {\n      virtualTriggerAriaStopWatch?.()\n      virtualTriggerAriaStopWatch = undefined\n      if (isElement(el)) {\n        ;(\n          [\n            'onMouseenter',\n            'onMouseleave',\n            'onClick',\n            'onKeydown',\n            'onFocus',\n            'onBlur',\n            'onContextmenu',\n          ] as const\n        ).forEach((eventName) => {\n          const handler = props[eventName]\n          if (handler) {\n            ;(el as HTMLElement).addEventListener(\n              eventName.slice(2).toLowerCase(),\n              handler\n            )\n            ;(prevEl as HTMLElement)?.removeEventListener?.(\n              eventName.slice(2).toLowerCase(),\n              handler\n            )\n          }\n        })\n        virtualTriggerAriaStopWatch = watch(\n          [ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded],\n          (watches) => {\n            ;[\n              'aria-controls',\n              'aria-describedby',\n              'aria-haspopup',\n              'aria-expanded',\n            ].forEach((key, idx) => {\n              isNil(watches[idx])\n                ? el.removeAttribute(key)\n                : el.setAttribute(key, watches[idx]!)\n            })\n          },\n          { immediate: true }\n        )\n      }\n      if (isElement(prevEl)) {\n        ;[\n          'aria-controls',\n          'aria-describedby',\n          'aria-haspopup',\n          'aria-expanded',\n        ].forEach((key) => prevEl.removeAttribute(key))\n      }\n    },\n    {\n      immediate: true,\n    }\n  )\n})\n\nonBeforeUnmount(() => {\n  virtualTriggerAriaStopWatch?.()\n  virtualTriggerAriaStopWatch = undefined\n})\n\ndefineExpose({\n  /**\n   * @description trigger element\n   */\n  triggerRef,\n})\n</script>\n", "import type { InjectionKey, Ref } from 'vue'\n\nexport const FOCUS_AFTER_TRAPPED = 'focus-trap.focus-after-trapped'\nexport const FOCUS_AFTER_RELEASED = 'focus-trap.focus-after-released'\nexport const FOCUSOUT_PREVENTED = 'focus-trap.focusout-prevented'\nexport const FOCUS_AFTER_TRAPPED_OPTS: EventInit = {\n  cancelable: true,\n  bubbles: false,\n}\nexport const FOCUSOUT_PREVENTED_OPTS: EventInit = {\n  cancelable: true,\n  bubbles: false,\n}\n\nexport const ON_TRAP_FOCUS_EVT = 'focusAfterTrapped'\nexport const ON_RELEASE_FOCUS_EVT = 'focusAfterReleased'\n\nexport type FocusTrapInjectionContext = {\n  focusTrapRef: Ref<HTMLElement | undefined>\n  onKeydown: (e: KeyboardEvent) => void\n}\n\nexport const FOCUS_TRAP_INJECTION_KEY: InjectionKey<FocusTrapInjectionContext> =\n  Symbol('elFocusTrap')\n", "import { onBeforeUnmount, onMounted, ref } from 'vue'\nimport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS } from './tokens'\n\nconst focusReason = ref<'pointer' | 'keyboard'>()\nconst lastUserFocusTimestamp = ref<number>(0)\nconst lastAutomatedFocusTimestamp = ref<number>(0)\nlet focusReasonUserCount = 0\n\nexport type FocusLayer = {\n  paused: boolean\n  pause: () => void\n  resume: () => void\n}\n\nexport type FocusStack = FocusLayer[]\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  const nodes: HTMLElement[] = []\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (\n      node: Element & {\n        disabled: boolean\n        hidden: boolean\n        type: string\n        tabIndex: number\n      }\n    ) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden'\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP\n      return node.tabIndex >= 0 || node === document.activeElement\n        ? NodeFilter.FILTER_ACCEPT\n        : NodeFilter.FILTER_SKIP\n    },\n  })\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement)\n\n  return nodes\n}\n\nexport const getVisibleElement = (\n  elements: HTMLElement[],\n  container: HTMLElement\n) => {\n  for (const element of elements) {\n    if (!isHidden(element, container)) return element\n  }\n}\n\nexport const isHidden = (element: HTMLElement, container: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return false\n  if (getComputedStyle(element).visibility === 'hidden') return true\n\n  while (element) {\n    if (container && element === container) return false\n    if (getComputedStyle(element).display === 'none') return true\n    element = element.parentElement as HTMLElement\n  }\n\n  return false\n}\n\nexport const getEdges = (container: HTMLElement) => {\n  const focusable = obtainAllFocusableElements(container)\n  const first = getVisibleElement(focusable, container)\n  const last = getVisibleElement(focusable.reverse(), container)\n  return [first, last]\n}\n\nconst isSelectable = (\n  element: any\n): element is HTMLInputElement & { select: () => void } => {\n  return element instanceof HTMLInputElement && 'select' in element\n}\n\nexport const tryFocus = (\n  element?: HTMLElement | { focus: () => void } | null,\n  shouldSelect?: boolean\n) => {\n  if (element && element.focus) {\n    const prevFocusedElement = document.activeElement\n    element.focus({ preventScroll: true })\n    lastAutomatedFocusTimestamp.value = window.performance.now()\n    if (\n      element !== prevFocusedElement &&\n      isSelectable(element) &&\n      shouldSelect\n    ) {\n      element.select()\n    }\n  }\n}\n\nfunction removeFromStack<T>(list: T[], item: T) {\n  const copy = [...list]\n\n  const idx = list.indexOf(item)\n\n  if (idx !== -1) {\n    copy.splice(idx, 1)\n  }\n  return copy\n}\n\nconst createFocusableStack = () => {\n  let stack = [] as FocusStack\n\n  const push = (layer: FocusLayer) => {\n    const currentLayer = stack[0]\n\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause()\n    }\n\n    stack = removeFromStack(stack, layer)\n    stack.unshift(layer)\n  }\n\n  const remove = (layer: FocusLayer) => {\n    stack = removeFromStack(stack, layer)\n    stack[0]?.resume?.()\n  }\n\n  return {\n    push,\n    remove,\n  }\n}\n\nexport const focusFirstDescendant = (\n  elements: HTMLElement[],\n  shouldSelect = false\n) => {\n  const prevFocusedElement = document.activeElement\n  for (const element of elements) {\n    tryFocus(element, shouldSelect)\n    if (document.activeElement !== prevFocusedElement) return\n  }\n}\n\nexport const focusableStack = createFocusableStack()\n\nexport const isFocusCausedByUserEvent = (): boolean => {\n  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value\n}\n\nconst notifyFocusReasonPointer = () => {\n  focusReason.value = 'pointer'\n  lastUserFocusTimestamp.value = window.performance.now()\n}\n\nconst notifyFocusReasonKeydown = () => {\n  focusReason.value = 'keyboard'\n  lastUserFocusTimestamp.value = window.performance.now()\n}\n\nexport const useFocusReason = (): {\n  focusReason: typeof focusReason\n  lastUserFocusTimestamp: typeof lastUserFocusTimestamp\n  lastAutomatedFocusTimestamp: typeof lastAutomatedFocusTimestamp\n} => {\n  onMounted(() => {\n    if (focusReasonUserCount === 0) {\n      document.addEventListener('mousedown', notifyFocusReasonPointer)\n      document.addEventListener('touchstart', notifyFocusReasonPointer)\n      document.addEventListener('keydown', notifyFocusReasonKeydown)\n    }\n    focusReasonUserCount++\n  })\n\n  onBeforeUnmount(() => {\n    focusReasonUserCount--\n    if (focusReasonUserCount <= 0) {\n      document.removeEventListener('mousedown', notifyFocusReasonPointer)\n      document.removeEventListener('touchstart', notifyFocusReasonPointer)\n      document.removeEventListener('keydown', notifyFocusReasonKeydown)\n    }\n  })\n\n  return {\n    focusReason,\n    lastUserFocusTimestamp,\n    lastAutomatedFocusTimestamp,\n  }\n}\n\nexport const createFocusOutPreventedEvent = (\n  detail: CustomEventInit['detail']\n) => {\n  return new CustomEvent(FOCUSOUT_PREVENTED, {\n    ...FOCUSOUT_PREVENTED_OPTS,\n    detail,\n  })\n}\n", "<template>\n  <slot :handle-keydown=\"onKeydown\" />\n</template>\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  unref,\n  watch,\n} from 'vue'\nimport { isNil } from 'lodash-unified'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { useEscapeKeydown } from '@element-plus/hooks'\nimport { isString } from '@element-plus/utils'\nimport {\n  createFocusOutPreventedEvent,\n  focusFirstDescendant,\n  focusableStack,\n  getEdges,\n  isFocusCausedByUserEvent,\n  obtainAllFocusableElements,\n  tryFocus,\n  useFocusReason,\n} from './utils'\nimport {\n  FOCUS_AFTER_RELEASED,\n  FOCUS_AFTER_TRAPPED,\n  FOCUS_AFTER_TRAPPED_OPTS,\n  FOCUS_TRAP_INJECTION_KEY,\n  ON_RELEASE_FOCUS_EVT,\n  ON_TRAP_FOCUS_EVT,\n} from './tokens'\n\nimport type { PropType } from 'vue'\nimport type { FocusLayer } from './utils'\n\nexport default defineComponent({\n  name: 'ElFocusTrap',\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object as PropType<HTMLElement>,\n    focusStartEl: {\n      type: [Object, String] as PropType<'container' | 'first' | HTMLElement>,\n      default: 'first',\n    },\n  },\n  emits: [\n    ON_TRAP_FOCUS_EVT,\n    ON_RELEASE_FOCUS_EVT,\n    'focusin',\n    'focusout',\n    'focusout-prevented',\n    'release-requested',\n  ],\n  setup(props, { emit }) {\n    const forwardRef = ref<HTMLElement | undefined>()\n    let lastFocusBeforeTrapped: HTMLElement | null\n    let lastFocusAfterTrapped: HTMLElement | null\n\n    const { focusReason } = useFocusReason()\n\n    useEscapeKeydown((event) => {\n      if (props.trapped && !focusLayer.paused) {\n        emit('release-requested', event)\n      }\n    })\n\n    const focusLayer: FocusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true\n      },\n      resume() {\n        this.paused = false\n      },\n    }\n\n    const onKeydown = (e: KeyboardEvent) => {\n      if (!props.loop && !props.trapped) return\n      if (focusLayer.paused) return\n\n      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e\n      const { loop } = props\n      const isTabbing =\n        key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey\n\n      const currentFocusingEl = document.activeElement\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget as HTMLElement\n        const [first, last] = getEdges(container)\n        const isTabbable = first && last\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n            }\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n              if (loop) tryFocus(first, true)\n            }\n          } else if (\n            shiftKey &&\n            [first, container].includes(currentFocusingEl as HTMLElement)\n          ) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n              if (loop) tryFocus(last, true)\n            }\n          }\n        }\n      }\n    }\n\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown,\n    })\n\n    watch(\n      () => props.focusTrapEl,\n      (focusTrapEl) => {\n        if (focusTrapEl) {\n          forwardRef.value = focusTrapEl\n        }\n      },\n      { immediate: true }\n    )\n\n    watch([forwardRef], ([forwardRef], [oldForwardRef]) => {\n      if (forwardRef) {\n        forwardRef.addEventListener('keydown', onKeydown)\n        forwardRef.addEventListener('focusin', onFocusIn)\n        forwardRef.addEventListener('focusout', onFocusOut)\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener('keydown', onKeydown)\n        oldForwardRef.removeEventListener('focusin', onFocusIn)\n        oldForwardRef.removeEventListener('focusout', onFocusOut)\n      }\n    })\n\n    const trapOnFocus = (e: Event) => {\n      emit(ON_TRAP_FOCUS_EVT, e)\n    }\n    const releaseOnFocus = (e: Event) => emit(ON_RELEASE_FOCUS_EVT, e)\n\n    const onFocusIn = (e: FocusEvent) => {\n      const trapContainer = unref(forwardRef)\n      if (!trapContainer) return\n\n      const target = e.target as HTMLElement | null\n      const relatedTarget = e.relatedTarget as HTMLElement | null\n      const isFocusedInTrap = target && trapContainer.contains(target)\n\n      if (!props.trapped) {\n        const isPrevFocusedInTrap =\n          relatedTarget && trapContainer.contains(relatedTarget)\n        if (!isPrevFocusedInTrap) {\n          lastFocusBeforeTrapped = relatedTarget\n        }\n      }\n\n      if (isFocusedInTrap) emit('focusin', e)\n\n      if (focusLayer.paused) return\n\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target\n        } else {\n          tryFocus(lastFocusAfterTrapped, true)\n        }\n      }\n    }\n\n    const onFocusOut = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (focusLayer.paused || !trapContainer) return\n\n      if (props.trapped) {\n        const relatedTarget = (e as FocusEvent)\n          .relatedTarget as HTMLElement | null\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          // Give embedded focus layer time to pause this layer before reclaiming focus\n          // And only reclaim focus if it should currently be trapping\n          setTimeout(() => {\n            if (!focusLayer.paused && props.trapped) {\n              const focusoutPreventedEvent = createFocusOutPreventedEvent({\n                focusReason: focusReason.value,\n              })\n              emit('focusout-prevented', focusoutPreventedEvent)\n              if (!focusoutPreventedEvent.defaultPrevented) {\n                tryFocus(lastFocusAfterTrapped, true)\n              }\n            }\n          }, 0)\n        }\n      } else {\n        const target = e.target as HTMLElement | null\n        const isFocusedInTrap = target && trapContainer.contains(target)\n        if (!isFocusedInTrap) emit('focusout', e)\n      }\n    }\n\n    async function startTrap() {\n      // Wait for forwardRef to resolve\n      await nextTick()\n      const trapContainer = unref(forwardRef)\n      if (trapContainer) {\n        focusableStack.push(focusLayer)\n        const prevFocusedElement = trapContainer.contains(\n          document.activeElement\n        )\n          ? lastFocusBeforeTrapped\n          : document.activeElement\n        lastFocusBeforeTrapped = prevFocusedElement as HTMLElement | null\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement)\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(\n            FOCUS_AFTER_TRAPPED,\n            FOCUS_AFTER_TRAPPED_OPTS\n          )\n          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n          trapContainer.dispatchEvent(focusEvent)\n          if (!focusEvent.defaultPrevented) {\n            nextTick(() => {\n              let focusStartEl = props.focusStartEl\n              if (!isString(focusStartEl)) {\n                tryFocus(focusStartEl)\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = 'first'\n                }\n              }\n              if (focusStartEl === 'first') {\n                focusFirstDescendant(\n                  obtainAllFocusableElements(trapContainer),\n                  true\n                )\n              }\n              if (\n                document.activeElement === prevFocusedElement ||\n                focusStartEl === 'container'\n              ) {\n                tryFocus(trapContainer)\n              }\n            })\n          }\n        }\n      }\n    }\n\n    function stopTrap() {\n      const trapContainer = unref(forwardRef)\n\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n\n        const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {\n          ...FOCUS_AFTER_TRAPPED_OPTS,\n          detail: {\n            focusReason: focusReason.value,\n          },\n        })\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus)\n        trapContainer.dispatchEvent(releasedEvent)\n        if (\n          !releasedEvent.defaultPrevented &&\n          (focusReason.value == 'keyboard' ||\n            !isFocusCausedByUserEvent() ||\n            trapContainer.contains(document.activeElement))\n        ) {\n          tryFocus(lastFocusBeforeTrapped ?? document.body)\n        }\n\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus)\n        focusableStack.remove(focusLayer)\n      }\n    }\n\n    onMounted(() => {\n      if (props.trapped) {\n        startTrap()\n      }\n\n      watch(\n        () => props.trapped,\n        (trapped) => {\n          if (trapped) {\n            startTrap()\n          } else {\n            stopTrap()\n          }\n        }\n      )\n    })\n\n    onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap()\n      }\n    })\n\n    return {\n      onKeydown,\n    }\n  },\n})\n</script>\n", "import { placements } from '@popperjs/core'\nimport { buildProps, definePropType } from '@element-plus/utils'\n\nimport type { ExtractPropTypes, StyleValue } from 'vue'\nimport type { Options, Placement } from '@popperjs/core'\nimport type { Measurable } from './constants'\nimport type Content from './content.vue'\n\ntype ClassObjectType = Record<string, boolean>\ntype ClassType = string | ClassObjectType | ClassType[]\n\nconst POSITIONING_STRATEGIES = ['fixed', 'absolute'] as const\n\nexport interface CreatePopperInstanceParams {\n  referenceEl: Measurable\n  popperContentEl: HTMLElement\n  arrowEl: HTMLElement | undefined\n}\n\nexport const popperCoreConfigProps = buildProps({\n  boundariesPadding: {\n    type: Number,\n    default: 0,\n  },\n  fallbackPlacements: {\n    type: definePropType<Placement[]>(Array),\n    default: undefined,\n  },\n  gpuAcceleration: {\n    type: Boolean,\n    default: true,\n  },\n  /**\n   * @description offset of the Tooltip\n   */\n  offset: {\n    type: Number,\n    default: 12,\n  },\n  /**\n   * @description position of Tooltip\n   */\n  placement: {\n    type: String,\n    values: placements,\n    default: 'bottom',\n  },\n  /**\n   * @description [popper.js](https://popper.js.org/docs/v2/) parameters\n   */\n  popperOptions: {\n    type: definePropType<Partial<Options>>(Object),\n    default: () => ({}),\n  },\n  strategy: {\n    type: String,\n    values: POSITIONING_STRATEGIES,\n    default: 'absolute',\n  },\n} as const)\nexport type PopperCoreConfigProps = ExtractPropTypes<\n  typeof popperCoreConfigProps\n>\n\nexport const popperContentProps = buildProps({\n  ...popperCoreConfigProps,\n  id: String,\n  style: {\n    type: definePropType<StyleValue>([String, Array, Object]),\n  },\n  className: {\n    type: definePropType<ClassType>([String, Array, Object]),\n  },\n  effect: {\n    type: String,\n    default: 'dark',\n  },\n  visible: Boolean,\n  enterable: {\n    type: Boolean,\n    default: true,\n  },\n  pure: Boolean,\n  focusOnShow: {\n    type: Boolean,\n    default: false,\n  },\n  trapping: {\n    type: Boolean,\n    default: false,\n  },\n  popperClass: {\n    type: definePropType<ClassType>([String, Array, Object]),\n  },\n  popperStyle: {\n    type: definePropType<StyleValue>([String, Array, Object]),\n  },\n  referenceEl: {\n    type: definePropType<HTMLElement>(Object),\n  },\n  triggerTargetEl: {\n    type: definePropType<HTMLElement>(Object),\n  },\n  stopPopperMouseEvent: {\n    type: Boolean,\n    default: true,\n  },\n  ariaLabel: {\n    type: String,\n    default: undefined,\n  },\n  virtualTriggering: Boolean,\n  zIndex: Number,\n} as const)\nexport type PopperContentProps = ExtractPropTypes<typeof popperContentProps>\n\nexport const popperContentEmits = {\n  mouseenter: (evt: MouseEvent) => evt instanceof MouseEvent,\n  mouseleave: (evt: MouseEvent) => evt instanceof MouseEvent,\n  focus: () => true,\n  blur: () => true,\n  close: () => true,\n}\nexport type PopperContentEmits = typeof popperContentEmits\n\nexport type PopperContentInstance = InstanceType<typeof Content>\n\n/** @deprecated use `popperCoreConfigProps` instead, and it will be deprecated in the next major version */\nexport const usePopperCoreConfigProps = popperCoreConfigProps\n\n/** @deprecated use `popperContentProps` instead, and it will be deprecated in the next major version */\nexport const usePopperContentProps = popperContentProps\n\n/** @deprecated use `popperContentEmits` instead, and it will be deprecated in the next major version */\nexport const usePopperContentEmits = popperContentEmits\n\n/** @deprecated use `PopperCoreConfigProps` instead, and it will be deprecated in the next major version */\nexport type UsePopperCoreConfigProps = PopperCoreConfigProps\n\n/** @deprecated use `PopperContentProps` instead, and it will be deprecated in the next major version */\nexport type UsePopperContentProps = PopperContentProps\n\n/** @deprecated use `PopperContentInstance` instead, and it will be deprecated in the next major version */\nexport type ElPopperArrowContent = PopperContentInstance\n", "import { unrefElement } from '@vueuse/core'\nimport { isClient } from '@element-plus/utils'\n\nimport type { ComponentPublicInstance } from 'vue'\nimport type { MaybeRef } from '@vueuse/core'\nimport type { Modifier } from '@popperjs/core'\nimport type { Measurable } from './constants'\nimport type { PopperCoreConfigProps } from './content'\n\nexport const buildPopperOptions = (\n  props: PopperCoreConfigProps,\n  modifiers: Modifier<any, any>[] = []\n) => {\n  const { placement, strategy, popperOptions } = props\n  const options = {\n    placement,\n    strategy,\n    ...popperOptions,\n    modifiers: [...genModifiers(props), ...modifiers],\n  }\n\n  deriveExtraModifiers(options, popperOptions?.modifiers)\n  return options\n}\n\nexport const unwrapMeasurableEl = (\n  $el: MaybeRef<Measurable | undefined | ComponentPublicInstance>\n) => {\n  if (!isClient) return\n  return unrefElement($el as HTMLElement)\n}\n\nfunction genModifiers(options: PopperCoreConfigProps) {\n  const { offset, gpuAcceleration, fallbackPlacements } = options\n  return [\n    {\n      name: 'offset',\n      options: {\n        offset: [0, offset ?? 12],\n      },\n    },\n    {\n      name: 'preventOverflow',\n      options: {\n        padding: {\n          top: 2,\n          bottom: 2,\n          left: 5,\n          right: 5,\n        },\n      },\n    },\n    {\n      name: 'flip',\n      options: {\n        padding: 5,\n        fallbackPlacements,\n      },\n    },\n    {\n      name: 'computeStyles',\n      options: {\n        gpuAcceleration,\n      },\n    },\n  ]\n}\n\nfunction deriveExtraModifiers(\n  options: any,\n  modifiers: PopperCoreConfigProps['popperOptions']['modifiers']\n) {\n  if (modifiers) {\n    options.modifiers = [...options.modifiers, ...(modifiers ?? [])]\n  }\n}\n", "import { computed, inject, onMounted, ref, unref, watch } from 'vue'\nimport { isUndefined } from 'lodash-unified'\nimport { usePopper } from '@element-plus/hooks'\nimport { POPPER_INJECTION_KEY } from '../constants'\nimport { buildPopperOptions, unwrapMeasurableEl } from '../utils'\n\nimport type { Modifier } from '@popperjs/core'\nimport type { PartialOptions } from '@element-plus/hooks'\nimport type { PopperContentProps } from '../content'\n\nconst DEFAULT_ARROW_OFFSET = 0\n\nexport const usePopperContent = (props: PopperContentProps) => {\n  const { popperInstanceRef, contentRef, triggerRef, role } = inject(\n    POPPER_INJECTION_KEY,\n    undefined\n  )!\n\n  const arrowRef = ref<HTMLElement>()\n  const arrowOffset = ref<number>()\n\n  const eventListenerModifier = computed(() => {\n    return {\n      name: 'eventListeners',\n      enabled: !!props.visible,\n    } as Modifier<'eventListeners', any>\n  })\n\n  const arrowModifier = computed(() => {\n    const arrowEl = unref(arrowRef)\n    const offset = unref(arrowOffset) ?? DEFAULT_ARROW_OFFSET\n    // Seems like the `phase` and `fn` is required by Modifier type\n    // But on its documentation they didn't specify that.\n    // Refer to https://popper.js.org/docs/v2/modifiers/arrow/\n    return {\n      name: 'arrow',\n      enabled: !isUndefined(arrowEl),\n      options: {\n        element: arrowEl,\n        padding: offset,\n      },\n    } as any\n  })\n\n  const options = computed<PartialOptions>(() => {\n    return {\n      onFirstUpdate: () => {\n        update()\n      },\n      ...buildPopperOptions(props, [\n        unref(arrowModifier),\n        unref(eventListenerModifier),\n      ]),\n    }\n  })\n\n  const computedReference = computed(\n    () => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef)\n  )\n\n  const { attributes, state, styles, update, forceUpdate, instanceRef } =\n    usePopper(computedReference, contentRef, options)\n\n  watch(instanceRef, (instance) => (popperInstanceRef.value = instance))\n\n  onMounted(() => {\n    watch(\n      () => unref(computedReference)?.getBoundingClientRect(),\n      () => {\n        update()\n      }\n    )\n  })\n\n  return {\n    attributes,\n    arrowRef,\n    contentRef,\n    instanceRef,\n    state,\n    styles,\n    role,\n\n    forceUpdate,\n    update,\n  }\n}\n\nexport type UsePopperContentReturn = ReturnType<typeof usePopperContent>\n", "import { computed, ref, unref } from 'vue'\nimport { useNamespace, useZIndex } from '@element-plus/hooks'\n\nimport type { CSSProperties, StyleValue } from 'vue'\nimport type { UsePopperReturn } from '@element-plus/hooks'\nimport type { UsePopperContentReturn } from './use-content'\nimport type { PopperContentProps } from '../content'\n\nexport const usePopperContentDOM = (\n  props: PopperContentProps,\n  {\n    attributes,\n    styles,\n    role,\n  }: Pick<UsePopperReturn, 'attributes' | 'styles'> &\n    Pick<UsePopperContentReturn, 'role'>\n) => {\n  const { nextZIndex } = useZIndex()\n  const ns = useNamespace('popper')\n\n  const contentAttrs = computed(() => unref(attributes).popper)\n  const contentZIndex = ref<number>(props.zIndex || nextZIndex())\n  const contentClass = computed(() => [\n    ns.b(),\n    ns.is('pure', props.pure),\n    ns.is(props.effect),\n    props.popperClass,\n  ])\n  const contentStyle = computed<StyleValue[]>(() => {\n    return [\n      { zIndex: unref(contentZIndex) } as CSSProperties,\n      props.popperStyle || {},\n      unref(styles).popper as CSSProperties,\n    ]\n  })\n  const ariaModal = computed<string | undefined>(() =>\n    role.value === 'dialog' ? 'false' : undefined\n  )\n  const arrowStyle = computed(\n    () => (unref(styles).arrow || {}) as CSSProperties\n  )\n\n  const updateZIndex = () => {\n    contentZIndex.value = props.zIndex || nextZIndex()\n  }\n\n  return {\n    ariaModal,\n    arrowStyle,\n    contentAttrs,\n    contentClass,\n    contentStyle,\n    contentZIndex,\n\n    updateZIndex,\n  }\n}\n\nexport type UsePopperContentDOMReturn = ReturnType<typeof usePopperContentDOM>\n", "import { ref } from 'vue'\n\nimport type { SetupContext } from 'vue'\nimport type { PopperContentEmits, PopperContentProps } from '../content'\n\nexport const usePopperContentFocusTrap = (\n  props: PopperContentProps,\n  emit: SetupContext<PopperContentEmits>['emit']\n) => {\n  const trapped = ref(false)\n  const focusStartRef = ref<'container' | 'first' | HTMLElement>()\n\n  const onFocusAfterTrapped = () => {\n    emit('focus')\n  }\n\n  const onFocusAfterReleased = (event: CustomEvent) => {\n    if (event.detail?.focusReason !== 'pointer') {\n      focusStartRef.value = 'first'\n      emit('blur')\n    }\n  }\n\n  const onFocusInTrap = (event: FocusEvent) => {\n    if (props.visible && !trapped.value) {\n      if (event.target) {\n        focusStartRef.value = event.target as typeof focusStartRef.value\n      }\n      trapped.value = true\n    }\n  }\n\n  const onFocusoutPrevented = (event: CustomEvent) => {\n    if (!props.trapping) {\n      if (event.detail.focusReason === 'pointer') {\n        event.preventDefault()\n      }\n      trapped.value = false\n    }\n  }\n\n  const onReleaseRequested = () => {\n    trapped.value = false\n    emit('close')\n  }\n\n  return {\n    focusStartRef,\n    trapped,\n\n    onFocusAfterReleased,\n    onFocusAfterTrapped,\n    onFocusInTrap,\n    onFocusoutPrevented,\n    onReleaseRequested,\n  }\n}\n\nexport type UsePopperContentFocusTrapReturn = ReturnType<\n  typeof usePopperContentFocusTrap\n>\n", "<template>\n  <div\n    ref=\"contentRef\"\n    v-bind=\"contentAttrs\"\n    :style=\"contentStyle\"\n    :class=\"contentClass\"\n    tabindex=\"-1\"\n    @mouseenter=\"(e) => $emit('mouseenter', e)\"\n    @mouseleave=\"(e) => $emit('mouseleave', e)\"\n  >\n    <el-focus-trap\n      :trapped=\"trapped\"\n      :trap-on-focus-in=\"true\"\n      :focus-trap-el=\"contentRef\"\n      :focus-start-el=\"focusStartRef\"\n      @focus-after-trapped=\"onFocusAfterTrapped\"\n      @focus-after-released=\"onFocusAfterReleased\"\n      @focusin=\"onFocusInTrap\"\n      @focusout-prevented=\"onFocusoutPrevented\"\n      @release-requested=\"onReleaseRequested\"\n    >\n      <slot />\n    </el-focus-trap>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  inject,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  unref,\n  watch,\n} from 'vue'\nimport { NOOP } from '@vue/shared'\nimport { isNil } from 'lodash-unified'\nimport ElFocusTrap from '@element-plus/components/focus-trap'\nimport { formItemContextKey } from '@element-plus/components/form'\nimport { isElement } from '@element-plus/utils'\nimport { POPPER_CONTENT_INJECTION_KEY } from './constants'\nimport { popperContentEmits, popperContentProps } from './content'\nimport {\n  usePopperContent,\n  usePopperContentDOM,\n  usePopperContentFocusTrap,\n} from './composables'\n\nimport type { WatchStopHandle } from 'vue'\n\ndefineOptions({\n  name: 'ElPopperContent',\n})\n\nconst emit = defineEmits(popperContentEmits)\n\nconst props = defineProps(popperContentProps)\n\nconst {\n  focusStartRef,\n  trapped,\n\n  onFocusAfterReleased,\n  onFocusAfterTrapped,\n  onFocusInTrap,\n  onFocusoutPrevented,\n  onReleaseRequested,\n} = usePopperContentFocusTrap(props, emit)\n\nconst { attributes, arrowRef, contentRef, styles, instanceRef, role, update } =\n  usePopperContent(props)\n\nconst {\n  ariaModal,\n  arrowStyle,\n  contentAttrs,\n  contentClass,\n  contentStyle,\n  updateZIndex,\n} = usePopperContentDOM(props, {\n  styles,\n  attributes,\n  role,\n})\n\nconst formItemContext = inject(formItemContextKey, undefined)\nconst arrowOffset = ref<number>()\n\nprovide(POPPER_CONTENT_INJECTION_KEY, {\n  arrowStyle,\n  arrowRef,\n  arrowOffset,\n})\n\nif (\n  formItemContext &&\n  (formItemContext.addInputId || formItemContext.removeInputId)\n) {\n  // disallow auto-id from inside popper content\n  provide(formItemContextKey, {\n    ...formItemContext,\n    addInputId: NOOP,\n    removeInputId: NOOP,\n  })\n}\n\nlet triggerTargetAriaStopWatch: WatchStopHandle | undefined = undefined\n\nconst updatePopper = (shouldUpdateZIndex = true) => {\n  update()\n  shouldUpdateZIndex && updateZIndex()\n}\n\nconst togglePopperAlive = () => {\n  updatePopper(false)\n  if (props.visible && props.focusOnShow) {\n    trapped.value = true\n  } else if (props.visible === false) {\n    trapped.value = false\n  }\n}\n\nonMounted(() => {\n  watch(\n    () => props.triggerTargetEl,\n    (triggerTargetEl, prevTriggerTargetEl) => {\n      triggerTargetAriaStopWatch?.()\n      triggerTargetAriaStopWatch = undefined\n\n      const el = unref(triggerTargetEl || contentRef.value)\n      const prevEl = unref(prevTriggerTargetEl || contentRef.value)\n\n      if (isElement(el)) {\n        triggerTargetAriaStopWatch = watch(\n          [role, () => props.ariaLabel, ariaModal, () => props.id],\n          (watches) => {\n            ;['role', 'aria-label', 'aria-modal', 'id'].forEach((key, idx) => {\n              isNil(watches[idx])\n                ? el.removeAttribute(key)\n                : el.setAttribute(key, watches[idx]!)\n            })\n          },\n          { immediate: true }\n        )\n      }\n      if (prevEl !== el && isElement(prevEl)) {\n        ;['role', 'aria-label', 'aria-modal', 'id'].forEach((key) => {\n          prevEl.removeAttribute(key)\n        })\n      }\n    },\n    { immediate: true }\n  )\n\n  watch(() => props.visible, togglePopperAlive, { immediate: true })\n})\n\nonBeforeUnmount(() => {\n  triggerTargetAriaStopWatch?.()\n  triggerTargetAriaStopWatch = undefined\n})\n\ndefineExpose({\n  /**\n   * @description popper content element\n   */\n  popperContentRef: contentRef,\n  /**\n   * @description popperjs instance\n   */\n  popperInstanceRef: instanceRef,\n  /**\n   * @description method for updating popper\n   */\n  updatePopper,\n\n  /**\n   * @description content style\n   */\n  contentStyle,\n})\n</script>\n", "import { withInstall } from '@element-plus/utils'\nimport Popper from './src/popper.vue'\n\nimport ElPopperArrow from './src/arrow.vue'\nimport ElPopperTrigger from './src/trigger.vue'\nimport ElPopperContent from './src/content.vue'\n\nexport { ElPopperArrow, ElPopperTrigger, ElPopperContent }\n\nexport const ElPopper = withInstall(Popper)\nexport default ElPopper\n\nexport * from './src/popper'\nexport * from './src/trigger'\nexport * from './src/content'\nexport * from './src/arrow'\nexport * from './src/constants'\n\nexport type { Placement, Options } from '@popperjs/core'\n", "import type { Arrayable } from '@element-plus/utils'\nimport type { InjectionKey, Ref } from 'vue'\nimport type { TooltipTriggerType } from './trigger'\n\nexport type ElTooltipInjectionContext = {\n  controlled: Ref<boolean>\n  id: Ref<string>\n  open: Ref<boolean>\n  trigger: Ref<Arrayable<TooltipTriggerType>>\n  onOpen: (e?: Event) => void\n  onClose: (e?: Event) => void\n  onToggle: (e: Event) => void\n  onShow: () => void\n  onHide: () => void\n  onBeforeShow: () => void\n  onBeforeHide: () => void\n  updatePopper: () => void\n}\n\nexport const TOOLTIP_INJECTION_KEY: InjectionKey<ElTooltipInjectionContext> =\n  Symbol('elTooltip')\n", "import { buildProps, definePropType } from '@element-plus/utils'\nimport { popperContentProps } from '@element-plus/components/popper'\nimport { useDelayedToggleProps } from '@element-plus/hooks'\n\nimport type TooltipContent from './content.vue'\nimport type { ExtractPropTypes } from 'vue'\n\nexport const useTooltipContentProps = buildProps({\n  ...useDelayedToggleProps,\n  ...popperContentProps,\n  /**\n   * @description which element the tooltip CONTENT appends to\n   */\n  appendTo: {\n    type: definePropType<string | HTMLElement>([String, Object]),\n  },\n  /**\n   * @description display content, can be overridden by `slot#content`\n   */\n  content: {\n    type: String,\n    default: '',\n  },\n  /**\n   * @description whether `content` is treated as HTML string\n   */\n  rawContent: {\n    type: Boolean,\n    default: false,\n  },\n  /**\n   * @description when tooltip inactive and `persistent` is `false` , popconfirm will be destroyed\n   */\n  persistent: Boolean,\n  /**\n   * @description same as `aria-label`\n   */\n  ariaLabel: String,\n  // because model toggle prop is generated dynamically\n  // so the typing cannot be evaluated by typescript as type:\n  // [name]: { type: Boolean, default: null }\n  // so we need to declare that again for type checking.\n  /**\n   * @description visibility of Tooltip\n   */\n  visible: {\n    type: definePropType<boolean | null>(Boolean),\n    default: null,\n  },\n  /**\n   * @description animation name\n   */\n  transition: String,\n  /**\n   * @description whether tooltip content is teleported, if `true` it will be teleported to where `append-to` sets\n   */\n  teleported: {\n    type: Boolean,\n    default: true,\n  },\n  /**\n   * @description whether Tooltip is disabled\n   */\n  disabled: Boolean,\n} as const)\n\nexport type ElTooltipContentProps = ExtractPropTypes<\n  typeof useTooltipContentProps\n>\n\nexport type TooltipContentInstance = InstanceType<typeof TooltipContent>\n", "import { buildProps, definePropType } from '@element-plus/utils'\nimport { popperTriggerProps } from '@element-plus/components/popper'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport type { Arrayable } from '@element-plus/utils'\nimport type { ExtractPropTypes } from 'vue'\n\nexport type TooltipTriggerType = 'hover' | 'focus' | 'click' | 'contextmenu'\n\nexport const useTooltipTriggerProps = buildProps({\n  ...popperTriggerProps,\n  /**\n   * @description whether Tooltip is disabled\n   */\n  disabled: Boolean,\n  /**\n   * @description How should the tooltip be triggered (to show)\n   */\n  trigger: {\n    type: definePropType<Arrayable<TooltipTriggerType>>([String, Array]),\n    default: 'hover',\n  },\n  /**\n   * @description When you click the mouse to focus on the trigger element, you can define a set of keyboard codes to control the display of tooltip through the keyboard\n   */\n  triggerKeys: {\n    type: definePropType<string[]>(Array),\n    default: () => [EVENT_CODE.enter, EVENT_CODE.space],\n  },\n} as const)\n\nexport type ElTooltipTriggerProps = ExtractPropTypes<\n  typeof useTooltipTriggerProps\n>\n", "import { buildProps } from '@element-plus/utils'\nimport { createModelToggleComposable } from '@element-plus/hooks'\nimport { popperArrowProps, popperProps } from '@element-plus/components/popper'\nimport { useTooltipContentProps } from './content'\nimport { useTooltipTriggerProps } from './trigger'\nimport type Tooltip from './tooltip.vue'\n\nimport type { ExtractPropTypes } from 'vue'\n\nexport const {\n  useModelToggleProps: useTooltipModelToggleProps,\n  useModelToggleEmits: useTooltipModelToggleEmits,\n  useModelToggle: useTooltipModelToggle,\n} = createModelToggleComposable('visible' as const)\n\nexport const useTooltipProps = buildProps({\n  ...popperProps,\n  ...useTooltipModelToggleProps,\n  ...useTooltipContentProps,\n  ...useTooltipTriggerProps,\n  ...popperArrowProps,\n  /**\n   * @description whether the tooltip content has an arrow\n   */\n  showArrow: {\n    type: Boolean,\n    default: true,\n  },\n})\n\nexport const tooltipEmits = [\n  ...useTooltipModelToggleEmits,\n  'before-show',\n  'before-hide',\n  'show',\n  'hide',\n  'open',\n  'close',\n]\n\nexport type ElTooltipProps = ExtractPropTypes<typeof useTooltipProps>\n\nexport type TooltipInstance = InstanceType<typeof Tooltip>\n", "import { unref } from 'vue'\nimport { isArray } from '@element-plus/utils'\nimport type { Arrayable } from '@element-plus/utils'\nimport type { Ref } from 'vue'\nimport type { TooltipTriggerType } from './trigger'\n\nexport const isTriggerType = (\n  trigger: Arrayable<TooltipTriggerType>,\n  type: TooltipTriggerType\n) => {\n  if (isArray(trigger)) {\n    return trigger.includes(type)\n  }\n  return trigger === type\n}\n\nexport const whenTrigger = (\n  trigger: Ref<Arrayable<TooltipTriggerType>>,\n  type: TooltipTriggerType,\n  handler: (e: Event) => void\n) => {\n  return (e: Event) => {\n    isTriggerType(unref(trigger), type) && handler(e)\n  }\n}\n", "<template>\n  <el-popper-trigger\n    :id=\"id\"\n    :virtual-ref=\"virtualRef\"\n    :open=\"open\"\n    :virtual-triggering=\"virtualTriggering\"\n    :class=\"ns.e('trigger')\"\n    @blur=\"onBlur\"\n    @click=\"onClick\"\n    @contextmenu=\"onContextMenu\"\n    @focus=\"onFocus\"\n    @mouseenter=\"onMouseenter\"\n    @mouseleave=\"onMouseleave\"\n    @keydown=\"onKeydown\"\n  >\n    <slot />\n  </el-popper-trigger>\n</template>\n<script lang=\"ts\" setup>\nimport { inject, ref, toRef, unref } from 'vue'\nimport { ElPopperTrigger } from '@element-plus/components/popper'\nimport { composeEventHandlers } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { TOOLTIP_INJECTION_KEY } from './constants'\nimport { useTooltipTriggerProps } from './trigger'\nimport { whenTrigger } from './utils'\nimport type { OnlyChildExpose } from '@element-plus/components/slot'\n\ndefineOptions({\n  name: 'ElTooltipTrigger',\n})\n\nconst props = defineProps(useTooltipTriggerProps)\n\nconst ns = useNamespace('tooltip')\nconst { controlled, id, open, onOpen, onClose, onToggle } = inject(\n  TOOLTIP_INJECTION_KEY,\n  undefined\n)!\n\nconst triggerRef = ref<OnlyChildExpose | null>(null)\n\nconst stopWhenControlledOrDisabled = () => {\n  if (unref(controlled) || props.disabled) {\n    return true\n  }\n}\nconst trigger = toRef(props, 'trigger')\nconst onMouseenter = composeEventHandlers(\n  stopWhenControlledOrDisabled,\n  whenTrigger(trigger, 'hover', onOpen)\n)\nconst onMouseleave = composeEventHandlers(\n  stopWhenControlledOrDisabled,\n  whenTrigger(trigger, 'hover', onClose)\n)\nconst onClick = composeEventHandlers(\n  stopWhenControlledOrDisabled,\n  whenTrigger(trigger, 'click', (e) => {\n    // distinguish left click\n    if ((e as MouseEvent).button === 0) {\n      onToggle(e)\n    }\n  })\n)\n\nconst onFocus = composeEventHandlers(\n  stopWhenControlledOrDisabled,\n  whenTrigger(trigger, 'focus', onOpen)\n)\n\nconst onBlur = composeEventHandlers(\n  stopWhenControlledOrDisabled,\n  whenTrigger(trigger, 'focus', onClose)\n)\n\nconst onContextMenu = composeEventHandlers(\n  stopWhenControlledOrDisabled,\n  whenTrigger(trigger, 'contextmenu', (e: Event) => {\n    e.preventDefault()\n    onToggle(e)\n  })\n)\n\nconst onKeydown = composeEventHandlers(\n  stopWhenControlledOrDisabled,\n  (e: KeyboardEvent) => {\n    const { code } = e\n    if (props.triggerKeys.includes(code)) {\n      e.preventDefault()\n      onToggle(e)\n    }\n  }\n)\n\ndefineExpose({\n  /**\n   * @description trigger element\n   */\n  triggerRef,\n})\n</script>\n", "<template>\n  <teleport :disabled=\"!teleported\" :to=\"appendTo\">\n    <transition\n      :name=\"transitionClass\"\n      @after-leave=\"onTransitionLeave\"\n      @before-enter=\"onBeforeEnter\"\n      @after-enter=\"onAfterShow\"\n      @before-leave=\"onBeforeLeave\"\n    >\n      <el-popper-content\n        v-if=\"shouldRender\"\n        v-show=\"shouldShow\"\n        :id=\"id\"\n        ref=\"contentRef\"\n        v-bind=\"$attrs\"\n        :aria-label=\"ariaLabel\"\n        :aria-hidden=\"ariaHidden\"\n        :boundaries-padding=\"boundariesPadding\"\n        :fallback-placements=\"fallbackPlacements\"\n        :gpu-acceleration=\"gpuAcceleration\"\n        :offset=\"offset\"\n        :placement=\"placement\"\n        :popper-options=\"popperOptions\"\n        :strategy=\"strategy\"\n        :effect=\"effect\"\n        :enterable=\"enterable\"\n        :pure=\"pure\"\n        :popper-class=\"popperClass\"\n        :popper-style=\"[popperStyle, contentStyle]\"\n        :reference-el=\"referenceEl\"\n        :trigger-target-el=\"triggerTargetEl\"\n        :visible=\"shouldShow\"\n        :z-index=\"zIndex\"\n        @mouseenter=\"onContentEnter\"\n        @mouseleave=\"onContentLeave\"\n        @blur=\"onBlur\"\n        @close=\"onClose\"\n      >\n        <template v-if=\"!destroyed\">\n          <slot />\n        </template>\n      </el-popper-content>\n    </transition>\n  </teleport>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed, inject, onBeforeUnmount, ref, unref, watch } from 'vue'\nimport { onClickOutside } from '@vueuse/core'\nimport { useNamespace, usePopperContainerId } from '@element-plus/hooks'\nimport { composeEventHandlers } from '@element-plus/utils'\nimport { ElPopperContent } from '@element-plus/components/popper'\nimport { TOOLTIP_INJECTION_KEY } from './constants'\nimport { useTooltipContentProps } from './content'\n\ndefineOptions({\n  name: 'ElTooltipContent',\n  inheritAttrs: false,\n})\n\nconst props = defineProps(useTooltipContentProps)\n\nconst { selector } = usePopperContainerId()\nconst ns = useNamespace('tooltip')\n// TODO any is temporary, replace with `InstanceType<typeof ElPopperContent> | null` later\nconst contentRef = ref<any>(null)\nconst destroyed = ref(false)\nconst {\n  controlled,\n  id,\n  open,\n  trigger,\n  onClose,\n  onOpen,\n  onShow,\n  onHide,\n  onBeforeShow,\n  onBeforeHide,\n} = inject(TOOLTIP_INJECTION_KEY, undefined)!\nconst transitionClass = computed(() => {\n  return props.transition || `${ns.namespace.value}-fade-in-linear`\n})\nconst persistentRef = computed(() => {\n  // For testing, we would always want the content to be rendered\n  // to the DOM, so we need to return true here.\n  if (process.env.NODE_ENV === 'test') {\n    return true\n  }\n  return props.persistent\n})\n\nonBeforeUnmount(() => {\n  destroyed.value = true\n})\n\nconst shouldRender = computed(() => {\n  return unref(persistentRef) ? true : unref(open)\n})\n\nconst shouldShow = computed(() => {\n  return props.disabled ? false : unref(open)\n})\n\nconst appendTo = computed(() => {\n  return props.appendTo || selector.value\n})\n\nconst contentStyle = computed(() => (props.style ?? {}) as any)\n\nconst ariaHidden = computed(() => !unref(open))\n\nconst onTransitionLeave = () => {\n  onHide()\n}\n\nconst stopWhenControlled = () => {\n  if (unref(controlled)) return true\n}\n\nconst onContentEnter = composeEventHandlers(stopWhenControlled, () => {\n  if (props.enterable && unref(trigger) === 'hover') {\n    onOpen()\n  }\n})\n\nconst onContentLeave = composeEventHandlers(stopWhenControlled, () => {\n  if (unref(trigger) === 'hover') {\n    onClose()\n  }\n})\n\nconst onBeforeEnter = () => {\n  contentRef.value?.updatePopper?.()\n  onBeforeShow?.()\n}\n\nconst onBeforeLeave = () => {\n  onBeforeHide?.()\n}\n\nconst onAfterShow = () => {\n  onShow()\n  stopHandle = onClickOutside(\n    computed(() => {\n      return contentRef.value?.popperContentRef\n    }),\n    () => {\n      if (unref(controlled)) return\n      const $trigger = unref(trigger)\n      if ($trigger !== 'hover') {\n        onClose()\n      }\n    }\n  )\n}\n\nconst onBlur = () => {\n  if (!props.virtualTriggering) {\n    onClose()\n  }\n}\n\nlet stopHandle: ReturnType<typeof onClickOutside>\n\nwatch(\n  () => unref(open),\n  (val) => {\n    if (!val) {\n      stopHandle?.()\n    }\n  },\n  {\n    flush: 'post',\n  }\n)\n\nwatch(\n  () => props.content,\n  () => {\n    contentRef.value?.updatePopper?.()\n  }\n)\n\ndefineExpose({\n  /**\n   * @description el-popper-content component instance\n   */\n  contentRef,\n})\n</script>\n", "<template>\n  <el-popper ref=\"popperRef\" :role=\"role\">\n    <el-tooltip-trigger\n      :disabled=\"disabled\"\n      :trigger=\"trigger\"\n      :trigger-keys=\"triggerKeys\"\n      :virtual-ref=\"virtualRef\"\n      :virtual-triggering=\"virtualTriggering\"\n    >\n      <slot v-if=\"$slots.default\" />\n    </el-tooltip-trigger>\n    <el-tooltip-content\n      ref=\"contentRef\"\n      :aria-label=\"ariaLabel\"\n      :boundaries-padding=\"boundariesPadding\"\n      :content=\"content\"\n      :disabled=\"disabled\"\n      :effect=\"effect\"\n      :enterable=\"enterable\"\n      :fallback-placements=\"fallbackPlacements\"\n      :hide-after=\"hideAfter\"\n      :gpu-acceleration=\"gpuAcceleration\"\n      :offset=\"offset\"\n      :persistent=\"persistent\"\n      :popper-class=\"popperClass\"\n      :popper-style=\"popperStyle\"\n      :placement=\"placement\"\n      :popper-options=\"popperOptions\"\n      :pure=\"pure\"\n      :raw-content=\"rawContent\"\n      :reference-el=\"referenceEl\"\n      :trigger-target-el=\"triggerTargetEl\"\n      :show-after=\"showAfter\"\n      :strategy=\"strategy\"\n      :teleported=\"teleported\"\n      :transition=\"transition\"\n      :virtual-triggering=\"virtualTriggering\"\n      :z-index=\"zIndex\"\n      :append-to=\"appendTo\"\n    >\n      <slot name=\"content\">\n        <span v-if=\"rawContent\" v-html=\"content\" />\n        <span v-else>{{ content }}</span>\n      </slot>\n      <el-popper-arrow v-if=\"showArrow\" :arrow-offset=\"arrowOffset\" />\n    </el-tooltip-content>\n  </el-popper>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  onDeactivated,\n  provide,\n  readonly,\n  ref,\n  toRef,\n  unref,\n  watch,\n} from 'vue'\nimport { ElPopper, ElPopperArrow } from '@element-plus/components/popper'\n\nimport { isBoolean } from '@element-plus/utils'\nimport {\n  useDelayedToggle,\n  useId,\n  usePopperContainer,\n} from '@element-plus/hooks'\nimport { TOOLTIP_INJECTION_KEY } from './constants'\nimport { tooltipEmits, useTooltipModelToggle, useTooltipProps } from './tooltip'\nimport ElTooltipTrigger from './trigger.vue'\nimport ElTooltipContent from './content.vue'\nimport type { PopperInstance } from '@element-plus/components/popper'\n\ndefineOptions({\n  name: 'ElTooltip',\n})\n\nconst props = defineProps(useTooltipProps)\nconst emit = defineEmits(tooltipEmits)\n\nusePopperContainer()\n\nconst id = useId()\nconst popperRef = ref<PopperInstance>()\n// TODO any is temporary, replace with `TooltipContentInstance` later\nconst contentRef = ref<any>()\n\nconst updatePopper = () => {\n  const popperComponent = unref(popperRef)\n  if (popperComponent) {\n    popperComponent.popperInstanceRef?.update()\n  }\n}\nconst open = ref(false)\nconst toggleReason = ref<Event>()\n\nconst { show, hide, hasUpdateHandler } = useTooltipModelToggle({\n  indicator: open,\n  toggleReason,\n})\n\nconst { onOpen, onClose } = useDelayedToggle({\n  showAfter: toRef(props, 'showAfter'),\n  hideAfter: toRef(props, 'hideAfter'),\n  autoClose: toRef(props, 'autoClose'),\n  open: show,\n  close: hide,\n})\n\nconst controlled = computed(\n  () => isBoolean(props.visible) && !hasUpdateHandler.value\n)\n\nprovide(TOOLTIP_INJECTION_KEY, {\n  controlled,\n  id,\n  open: readonly(open),\n  trigger: toRef(props, 'trigger'),\n  onOpen: (event?: Event) => {\n    onOpen(event)\n  },\n  onClose: (event?: Event) => {\n    onClose(event)\n  },\n  onToggle: (event?: Event) => {\n    if (unref(open)) {\n      onClose(event)\n    } else {\n      onOpen(event)\n    }\n  },\n  onShow: () => {\n    emit('show', toggleReason.value)\n  },\n  onHide: () => {\n    emit('hide', toggleReason.value)\n  },\n  onBeforeShow: () => {\n    emit('before-show', toggleReason.value)\n  },\n  onBeforeHide: () => {\n    emit('before-hide', toggleReason.value)\n  },\n  updatePopper,\n})\n\nwatch(\n  () => props.disabled,\n  (disabled) => {\n    if (disabled && open.value) {\n      open.value = false\n    }\n  }\n)\n\nconst isFocusInsideContent = () => {\n  const popperContent: HTMLElement | undefined =\n    contentRef.value?.contentRef?.popperContentRef\n  return popperContent && popperContent.contains(document.activeElement)\n}\n\nonDeactivated(() => open.value && hide())\n\ndefineExpose({\n  /**\n   * @description el-popper component instance\n   */\n  popperRef,\n  /**\n   * @description el-tooltip-content component instance\n   */\n  contentRef,\n  /**\n   * @description validate current focus event is trigger inside el-tooltip-content\n   */\n  isFocusInsideContent,\n  /**\n   * @description update el-popper component instance\n   */\n  updatePopper,\n  /**\n   * @description expose onOpen function to mange el-tooltip open state\n   */\n  onOpen,\n  /**\n   * @description expose onOpen function to mange el-tooltip open state\n   */\n  onClose,\n  /**\n   * @description expose hide function\n   */\n  hide,\n})\n</script>\n", "import { withInstall } from '@element-plus/utils'\nimport Tooltip from './src/tooltip.vue'\n\nexport const ElTooltip = withInstall(Tooltip)\nexport * from './src/tooltip'\nexport * from './src/trigger'\nexport * from './src/content'\nexport * from './src/constants'\nexport default ElTooltip\n"],
  "mappings": "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",
  "names": ["NAME", "OnlyChild", "defineComponent", "name", "slots", "attrs", "forwardRefInjection", "inject", "FORWARD_REF_INJECTION_KEY", "forwardRefDirective", "useForwardRefDirective", "setForwardRef", "NOOP", "defaultSlot", "debugWarn", "firstLegitNode", "findFirstLegitChild", "node", "children", "child", "isObject", "Fragment", "_createVNode", "_sfc_main", "focusReason", "_renderSlot"]
}
